#include <core/pdb.h>
#include "core/processing.h"
#include "core/radius.h"
#include "core/pca.h"
#include "core/score.h"
#include <thread>
#include <fstream>
#include <cds/container/fcpriority_queue.h>
#include <fmt/format.h>
#include <CGAL/Aff_transformation_3.h>
#include <CGAL/Polygon_mesh_processing/transform.h>

#define ALL_SETTINGS            \
  X(bool, pca_align, false, "align the grid using PCA, with maximum variance on the X axis") \
  X(std::string, ligand_file, "", "The file of the ligand pdb")                                   \
  X(std::string, grid_file, "", "A file generated by gridify")                               \
  X(double, scale_radius, 1.0, "The scale factor for atomic radii (default 1)")

#include "core/cmdline.inc"

bool g_verbose = true;


site_ligand_stats process_frame(const config &c,
                                const pdb_frame &f,
                                const Surface_Mesh &ligand_mesh,
                                double grid_radius)
{
  std::vector<Point_3> points;
  for (const auto &a : f.atoms) {
    points.push_back(a.pos);
  }

  if (c.pca_align) {
    points = pca_aligned_points(points);
  }

  return calc_grid_ligand_stats(points, ligand_mesh, grid_radius);
}



int main(int argc, char *argv[])
{
  auto config = parse_cmd_line_settings("scorer",
                                        "calculate intersection between a ligand and a grid file",
                                        argc, argv, [](cxxopts::Options &){});

  auto ligand_file = std::ifstream(config.ligand_file);
  auto grid_file = std::ifstream(config.grid_file);

  double grid_radius = parse_pdb_gridify_spacing(grid_file);

  grid_file.seekg(0);

  producer_consumer_queue queue_ligand, queue;


  //std::thread producer([&] { parse_pdb(pdb_file, queue); });

  parse_pdb(ligand_file, queue_ligand);

  pdb_frame frame;
  if (!queue_ligand.frames.try_dequeue(frame)) {
    // TODO error.
  }

  auto ligand_mesh = gen_ligand_geometry(frame, config.scale_radius, config.pca_align);

  {
    std::ofstream f("ligand.off");
    f << ligand_mesh;
    f.close();
  }

  std::thread producer([&] {parse_pdb(grid_file, queue);});

  processed_queue<site_ligand_stats> processed_frames;

  std::vector<std::thread> consumers;
  int num_consumers = 1;
  for (int j = 0; j < num_consumers; ++j) {
    consumers.emplace_back(process_frame_loop(num_consumers, queue, processed_frames,
                                              [&](const pdb_frame &frame) {
                                                return process_frame(config, frame, ligand_mesh, grid_radius);
                                              }));
  }


  process_serialized_results(
      num_consumers, queue, processed_frames,
      [&](int frame_idx, site_ligand_stats &data) {
        fmt::print("-- writing frame {}\n", frame_idx);
        fmt::print("SITE VOLUME:         {:.3}\n", data.site_volume);
        fmt::print("LIGAND VOLUME:       {:.3}\n", data.ligand_volume);
        fmt::print("INTERSECTION VOLUME: {:.3}\n", data.intersection_volume);
        fmt::print("UNION VOLUME:        {:.3}\n", data.union_volume);
        fmt::print("IOU: {:.3}\n", data.intersection_volume / data.union_volume);
        fmt::print("IOL: {:.3}\n", data.intersection_volume / data.ligand_volume);
        fmt::print("IOS: {:.3}\n", data.intersection_volume / data.site_volume);
      });


  producer.join();
  for (auto &c : consumers) {
    c.join();
  }
}